"use strict";(self.webpackChunkp8g_docs=self.webpackChunkp8g_docs||[]).push([[3274],{7761:function(n,e,t){t.r(e),t.d(e,{assets:function(){return m},contentTitle:function(){return p},default:function(){return g},frontMatter:function(){return d},metadata:function(){return h},toc:function(){return f}});var r=t(3117),o=t(102),i=(t(7294),t(3905)),a=t(5488),s=t(5162),l=t(9819),c=t(4678),u=["components"],d={description:"C++"},p="A* search algorithm",h={unversionedId:"astar",id:"astar",title:"A* search algorithm",description:"C++",source:"@site/examples/astar.md",sourceDirName:".",slug:"/astar",permalink:"/p8g/examples/astar",draft:!1,editUrl:"https://github.com/bernhardfritz/p8g/edit/master/docs/examples/astar.md",tags:[],version:"current",frontMatter:{description:"C++"},sidebar:"examples",previous:{title:"Examples",permalink:"/p8g/examples/"},next:{title:"Breakout",permalink:"/p8g/examples/breakout"}},m={},f=[],y={toc:f};function g(n){var e=n.components,t=(0,o.Z)(n,u);return(0,i.kt)("wrapper",(0,r.Z)({},y,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"a-search-algorithm"},"A* search algorithm"),(0,i.kt)(c.Z,{src:"/examples/astar.html",mdxType:"Emscripten"}),(0,i.kt)(a.Z,{groupId:"lang",mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(l.Z,{language:"cpp",title:"astar.cpp",mdxType:"CodeBlock"},'#include "astar.hpp"\n\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nstruct Node {\n    int x, y;\n    float gScore, hScore;\n    Node* cameFrom;\n\n    Node(int x, int y, float gScore, float hScore, Node* cameFrom)\n        : x(x)\n        , y(y)\n        , gScore(gScore)\n        , hScore(hScore)\n        , cameFrom(cameFrom) {\n    }\n\n    bool hasCoords(int x, int y) {\n        return this->x == x && this->y == y;\n    }\n};\n\nstruct NodeCompare {\n    bool operator()(const Node* a, const Node* b) {\n        return a->gScore + a->hScore > b->gScore + b->hScore;\n    }\n};\n\n/**\n * MyPriorityQueue is an extension of\n * std::priority_queue that allows iteration\n */\ntemplate<\n    class T,\n    class Container = std::vector<T>,\n    class Compare = std::less<typename Container::value_type>\n> struct MyPriorityQueue : std::priority_queue<T, Container, Compare> {\n    typename Container::iterator begin() {\n        return std::priority_queue<T, Container, Compare>::c.begin();\n    }\n    typename Container::iterator end() {\n        return std::priority_queue<T, Container, Compare>::c.end();\n    }\n};\n\nconst float SQUARE_ROOT_OF_TWO = sqrtf(2.0f);\n\nfloat AStar::heuristic_cost_estimate(int x1, int y1, int x2, int y2) {\n    if (moveDiagonally) {\n         // euclidian distance\n        return sqrtf(powf(x1 - x2, 2.0f) + powf(y1 - y2, 2.0f));\n    } else {\n        // manhattan distance\n        return abs(x1 - x2) + abs(y1 - y2);\n    }\n}\n\nbool AStar::isCollisionAt(int x, int y) {\n    return collisionGrid[y * cols + x];\n}\n\n/**\n * Implementation of A* search algorithm\n * based on https://en.wikipedia.org/wiki/A*_search_algorithm\n */\nstd::vector<std::pair<int, int>> AStar::findPath(\n    int x1, int y1, int x2, int y2\n) {\n    std::vector<std::pair<int, int>> path;\n    if (isCollisionAt(x1, y1) || isCollisionAt(x2, y2)) {\n        return path;\n    }\n    std::vector<Node*> closedSet;\n    MyPriorityQueue<Node*, std::vector<Node*>, NodeCompare> openSet;\n    Node* start = new Node(\n        x1, y1, 0.0f, heuristic_cost_estimate(x1, y1, x2, y2), nullptr\n    );\n    openSet.push(start);\n\n    Node* current = nullptr;\n    while (!openSet.empty()) {\n        current = openSet.top();\n        if (current->hasCoords(x2, y2)) {\n            break;\n        }\n\n        openSet.pop();\n        closedSet.push_back(current);\n\n        for (int i = 0; i < (moveDiagonally ? 8 : 4); i++) {\n            int x = current->x + directions[i].first;\n            int y = current->y + directions[i].second;\n            if (x < 0 || x >= cols \n                || y < 0 || y >= rows\n                || isCollisionAt(x, y)) {\n                continue;\n            }\n            bool cont = false;\n            for (Node* node : closedSet) {\n                if (node->hasCoords(x, y)) {\n                    cont = true;\n                    break;\n                }\n            }\n            if (cont) {\n                continue;\n            }\n\n            float dist_between = (i < 4 ? 1.0f : SQUARE_ROOT_OF_TWO);\n            int tentative_gScore = current->gScore + dist_between;\n\n            Node* neighbor = nullptr;\n            for (Node* node : openSet) {\n                if (node->hasCoords(x, y)) {\n                    neighbor = node;\n                    break;\n                }\n            }\n            if (neighbor == nullptr) { // neighbor not in openSet\n                neighbor = new Node(\n                    x,\n                    y,\n                    tentative_gScore,\n                    heuristic_cost_estimate(x, y, x2, y2),\n                    current\n                );\n                openSet.push(neighbor);\n            } else if (tentative_gScore < neighbor->gScore) {\n                neighbor->cameFrom = current;\n                neighbor->gScore = tentative_gScore;\n            }\n        }\n    }\n\n    if (current != nullptr && current->hasCoords(x2, y2)) {\n        while(current != nullptr) {\n            path.push_back({current->x, current->y});\n            current = current->cameFrom;\n        }\n        std::reverse(path.begin(), path.end());\n    }\n\n    return path;\n}'),(0,i.kt)(l.Z,{language:"cpp",title:"astar.hpp",mdxType:"CodeBlock"},"#ifndef ASTAR_HPP\n#define ASTAR_HPP\n\n#include <utility>\n#include <vector>\n\nclass AStar {\npublic:\n    AStar(const std::vector<bool>& collisionGrid,\n        int cols, int rows, bool moveDiagonally)\n        : collisionGrid(collisionGrid)\n        , cols(cols)\n        , rows(rows)\n        , moveDiagonally(moveDiagonally) {\n    }\n    std::vector<std::pair<int, int>> findPath(\n        int x1, int y1, int x2, int y2\n    );\n\nprivate:\n    const std::vector<bool>& collisionGrid;\n    int cols, rows;\n    bool moveDiagonally;\n    const std::vector<std::pair<int, int>> directions = {\n        { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 },\n        { -1, -1 }, { 1, 1 }, { -1, 1 }, { 1, -1 }\n    };\n    \n    float heuristic_cost_estimate(int x1, int y1, int x2, int y2);\n    bool isCollisionAt(int x, int y);\n};\n\n#endif /* ASTAR_HPP */"),(0,i.kt)(l.Z,{language:"cpp",title:"sketch.cpp",mdxType:"CodeBlock"},'#include <glm/glm.hpp>\n\n#include "p8g.hpp"\n#include "astar.hpp"\n\nusing namespace p8g;\n\nconst int rows = 100, cols = 100;\nfloat w, h, wh, hh;\nstd::vector<bool> collisionGrid(cols * rows);\nint gx = cols - 1, gy = rows - 1;\nAStar* astar;\nstd::vector<std::pair<int, int>> path;\n\nint coordsToIndex(int x, int y) {\n    return y * cols + x;\n}\n\nvoid initCollisionGrid() {\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < cols; x++) {\n            collisionGrid[coordsToIndex(x, y)] = p8g::random() < 0.25f;\n        }\n    }\n    // ensure there is no collision at the start point\n    collisionGrid[coordsToIndex(cols / 2, rows / 2)] = false;\n}\n\nvoid initAStar() {\n    delete astar;\n    astar = new AStar(collisionGrid, cols, rows, true);\n    path = astar->findPath(cols / 2, rows / 2, gx, gy);\n}\n\nvoid p8g::draw() {\n    background(255.f);\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < cols; x++) {\n            if (collisionGrid[coordsToIndex(x, y)]) {\n                stroke(0.f);\n                strokeWeight(w);\n                point(x * w + w / 2.0f, y * h + h / 2.0f);\n            }\n        }\n    }\n    if (path.size() > 1) {\n        for (int i = 1; i < path.size(); i++) {\n            stroke(255.f, 0.f, 255.f);\n            strokeWeight(wh);\n            line(\n                path[i - 1].first * w + wh,\n                path[i - 1].second * h + hh,\n                path[i].first * w + wh,\n                path[i].second * h + hh\n            );\n        }\n    }\n}\n\nvoid p8g::keyPressed() {}\nvoid p8g::keyReleased() {}\n\nvoid p8g::mouseMoved() {\n    int prevGx = gx, prevGy = gy;\n    gx = glm::clamp<int>(glm::min(mouseX, (float) width) / w, 0, cols - 1);\n    gy = glm::clamp<int>(glm::min(mouseY, (float) height) / h, 0, rows - 1);\n    if (gx != prevGx || gy != prevGy) {\n        initAStar();\n    }\n}\n\nvoid p8g::mousePressed() {}\nvoid p8g::mouseReleased() {}\nvoid p8g::mouseWheel(float delta) {}\n\nint main() {\n    const int WIDTH = 320;\n    const int HEIGHT = 320;\n    w = (float) WIDTH / cols;\n    h = (float) HEIGHT / rows;\n    wh = w / 2.0f;\n    hh = h / 2.0f;\n    initCollisionGrid();\n    initAStar();\n    run(WIDTH, HEIGHT, "A*");\n}'))))}g.isMDXComponent=!0},5162:function(n,e,t){t.d(e,{Z:function(){return a}});var r=t(7294),o=t(6010),i="tabItem_Ymn6";function a(n){var e=n.children,t=n.hidden,a=n.className;return r.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,a),hidden:t},e)}},5488:function(n,e,t){t.d(e,{Z:function(){return h}});var r=t(3117),o=t(7294),i=t(6010),a=t(2389),s=t(7392),l=t(7094),c=t(2466),u="tabList__CuJ",d="tabItem_LNqP";function p(n){var e,t,a=n.lazy,p=n.block,h=n.defaultValue,m=n.values,f=n.groupId,y=n.className,g=o.Children.map(n.children,(function(n){if((0,o.isValidElement)(n)&&"value"in n.props)return n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof n.type?n.type:n.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=m?m:g.map((function(n){var e=n.props;return{value:e.value,label:e.label,attributes:e.attributes}})),x=(0,s.l)(v,(function(n,e){return n.value===e.value}));if(x.length>0)throw new Error('Docusaurus error: Duplicate values "'+x.map((function(n){return n.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var b=null===h?h:null!=(e=null!=h?h:null==(t=g.find((function(n){return n.props.default})))?void 0:t.props.value)?e:g[0].props.value;if(null!==b&&!v.some((function(n){return n.value===b})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+v.map((function(n){return n.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var w=(0,l.U)(),S=w.tabGroupChoices,k=w.setTabGroupChoices,T=(0,o.useState)(b),_=T[0],C=T[1],A=[],N=(0,c.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var E=S[f];null!=E&&E!==_&&v.some((function(n){return n.value===E}))&&C(E)}var G=function(n){var e=n.currentTarget,t=A.indexOf(e),r=v[t].value;r!==_&&(N(e),C(r),null!=f&&k(f,String(r)))},I=function(n){var e,t=null;switch(n.key){case"ArrowRight":var r,o=A.indexOf(n.currentTarget)+1;t=null!=(r=A[o])?r:A[0];break;case"ArrowLeft":var i,a=A.indexOf(n.currentTarget)-1;t=null!=(i=A[a])?i:A[A.length-1]}null==(e=t)||e.focus()};return o.createElement("div",{className:(0,i.Z)("tabs-container",u)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":p},y)},v.map((function(n){var e=n.value,t=n.label,a=n.attributes;return o.createElement("li",(0,r.Z)({role:"tab",tabIndex:_===e?0:-1,"aria-selected":_===e,key:e,ref:function(n){return A.push(n)},onKeyDown:I,onFocus:G,onClick:G},a,{className:(0,i.Z)("tabs__item",d,null==a?void 0:a.className,{"tabs__item--active":_===e})}),null!=t?t:e)}))),a?(0,o.cloneElement)(g.filter((function(n){return n.props.value===_}))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},g.map((function(n,e){return(0,o.cloneElement)(n,{key:e,hidden:n.props.value!==_})}))))}function h(n){var e=(0,a.Z)();return o.createElement(p,(0,r.Z)({key:String(e)},n))}},4678:function(n,e,t){t.d(e,{Z:function(){return a}});var r=t(7294),o=t(6649),i=t(4996);function a(n){return r.createElement(o.Z,{src:(0,i.Z)(n.src),style:{width:"1px",minWidth:"100%"}})}}}]);