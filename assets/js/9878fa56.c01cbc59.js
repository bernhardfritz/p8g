"use strict";(self.webpackChunkp8g_docs=self.webpackChunkp8g_docs||[]).push([[3274],{7761:function(n,t,e){e.r(t),e.d(t,{assets:function(){return m},contentTitle:function(){return u},default:function(){return g},frontMatter:function(){return p},metadata:function(){return h},toc:function(){return y}});var o=e(3117),i=e(102),r=(e(7294),e(3905)),s=e(5488),a=e(5162),c=e(6975),l=e(4678),d=["components"],p={description:"C++"},u="A* search algorithm",h={unversionedId:"astar",id:"astar",title:"A* search algorithm",description:"C++",source:"@site/examples/astar.md",sourceDirName:".",slug:"/astar",permalink:"/p8g/examples/astar",draft:!1,editUrl:"https://github.com/bernhardfritz/p8g/edit/master/docs/examples/astar.md",tags:[],version:"current",frontMatter:{description:"C++"},sidebar:"examples",previous:{title:"Examples",permalink:"/p8g/examples/"},next:{title:"Fireworks",permalink:"/p8g/examples/fireworks"}},m={},y=[],f={toc:y};function g(n){var t=n.components,e=(0,i.Z)(n,d);return(0,r.kt)("wrapper",(0,o.Z)({},f,e,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"a-search-algorithm"},"A* search algorithm"),(0,r.kt)(l.Z,{src:"/examples/astar.html",mdxType:"Emscripten"}),(0,r.kt)(s.Z,{groupId:"lang",mdxType:"Tabs"},(0,r.kt)(a.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(c.Z,{language:"cpp",title:"astar.cpp",mdxType:"CodeBlock"},'#include "astar.hpp"\n\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nstruct Node {\n    int x, y;\n    float gScore, hScore;\n    Node* cameFrom;\n\n    Node(int x, int y, float gScore, float hScore, Node* cameFrom)\n        : x(x)\n        , y(y)\n        , gScore(gScore)\n        , hScore(hScore)\n        , cameFrom(cameFrom) {\n    }\n\n    bool hasCoords(int x, int y) {\n        return this->x == x && this->y == y;\n    }\n};\n\nstruct NodeCompare {\n    bool operator()(const Node* a, const Node* b) {\n        return a->gScore + a->hScore > b->gScore + b->hScore;\n    }\n};\n\n/**\n * MyPriorityQueue is an extension of\n * std::priority_queue that allows iteration\n */\ntemplate<\n    class T,\n    class Container = std::vector<T>,\n    class Compare = std::less<typename Container::value_type>\n> struct MyPriorityQueue : std::priority_queue<T, Container, Compare> {\n    typename Container::iterator begin() {\n        return std::priority_queue<T, Container, Compare>::c.begin();\n    }\n    typename Container::iterator end() {\n        return std::priority_queue<T, Container, Compare>::c.end();\n    }\n};\n\nconst float SQUARE_ROOT_OF_TWO = sqrtf(2.0f);\n\nfloat AStar::heuristic_cost_estimate(int x1, int y1, int x2, int y2) {\n    if (moveDiagonally) {\n         // euclidian distance\n        return sqrtf(powf(x1 - x2, 2.0f) + powf(y1 - y2, 2.0f));\n    } else {\n        // manhattan distance\n        return abs(x1 - x2) + abs(y1 - y2);\n    }\n}\n\nbool AStar::isCollisionAt(int x, int y) {\n    return collisionGrid[y * cols + x];\n}\n\n/**\n * Implementation of A* search algorithm\n * based on https://en.wikipedia.org/wiki/A*_search_algorithm\n */\nstd::vector<std::pair<int, int>> AStar::findPath(\n    int x1, int y1, int x2, int y2\n) {\n    std::vector<std::pair<int, int>> path;\n    if (isCollisionAt(x1, y1) || isCollisionAt(x2, y2)) {\n        return path;\n    }\n    std::vector<Node*> closedSet;\n    MyPriorityQueue<Node*, std::vector<Node*>, NodeCompare> openSet;\n    Node* start = new Node(\n        x1, y1, 0.0f, heuristic_cost_estimate(x1, y1, x2, y2), nullptr\n    );\n    openSet.push(start);\n\n    Node* current = nullptr;\n    while (!openSet.empty()) {\n        current = openSet.top();\n        if (current->hasCoords(x2, y2)) {\n            break;\n        }\n\n        openSet.pop();\n        closedSet.push_back(current);\n\n        for (int i = 0; i < (moveDiagonally ? 8 : 4); i++) {\n            int x = current->x + directions[i].first;\n            int y = current->y + directions[i].second;\n            if (x < 0 || x >= cols \n                || y < 0 || y >= rows\n                || isCollisionAt(x, y)) {\n                continue;\n            }\n            bool cont = false;\n            for (Node* node : closedSet) {\n                if (node->hasCoords(x, y)) {\n                    cont = true;\n                    break;\n                }\n            }\n            if (cont) {\n                continue;\n            }\n\n            float dist_between = (i < 4 ? 1.0f : SQUARE_ROOT_OF_TWO);\n            int tentative_gScore = current->gScore + dist_between;\n\n            Node* neighbor = nullptr;\n            for (Node* node : openSet) {\n                if (node->hasCoords(x, y)) {\n                    neighbor = node;\n                    break;\n                }\n            }\n            if (neighbor == nullptr) { // neighbor not in openSet\n                neighbor = new Node(\n                    x,\n                    y,\n                    tentative_gScore,\n                    heuristic_cost_estimate(x, y, x2, y2),\n                    current\n                );\n                openSet.push(neighbor);\n            } else if (tentative_gScore < neighbor->gScore) {\n                neighbor->cameFrom = current;\n                neighbor->gScore = tentative_gScore;\n            }\n        }\n    }\n\n    if (current != nullptr && current->hasCoords(x2, y2)) {\n        while(current != nullptr) {\n            path.push_back({current->x, current->y});\n            current = current->cameFrom;\n        }\n        std::reverse(path.begin(), path.end());\n    }\n\n    return path;\n}'),(0,r.kt)(c.Z,{language:"cpp",title:"astar.hpp",mdxType:"CodeBlock"},"#ifndef ASTAR_HPP\n#define ASTAR_HPP\n\n#include <utility>\n#include <vector>\n\nclass AStar {\npublic:\n    AStar(const std::vector<bool>& collisionGrid,\n        int cols, int rows, bool moveDiagonally)\n        : collisionGrid(collisionGrid)\n        , cols(cols)\n        , rows(rows)\n        , moveDiagonally(moveDiagonally) {\n    }\n    std::vector<std::pair<int, int>> findPath(\n        int x1, int y1, int x2, int y2\n    );\n\nprivate:\n    const std::vector<bool>& collisionGrid;\n    int cols, rows;\n    bool moveDiagonally;\n    const std::vector<std::pair<int, int>> directions = {\n        { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 },\n        { -1, -1 }, { 1, 1 }, { -1, 1 }, { 1, -1 }\n    };\n    \n    float heuristic_cost_estimate(int x1, int y1, int x2, int y2);\n    bool isCollisionAt(int x, int y);\n};\n\n#endif /* ASTAR_HPP */"),(0,r.kt)(c.Z,{language:"cpp",title:"sketch.cpp",mdxType:"CodeBlock"},'#include <glm/glm.hpp>\n\n#include "p8g.hpp"\n#include "astar.hpp"\n\nusing namespace p8g;\n\nconst int rows = 100, cols = 100;\nfloat w, h, wh, hh;\nstd::vector<bool> collisionGrid(cols * rows);\nint gx = cols - 1, gy = rows - 1;\nAStar* astar;\nstd::vector<std::pair<int, int>> path;\n\nint coordsToIndex(int x, int y) {\n    return y * cols + x;\n}\n\nvoid initCollisionGrid() {\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < cols; x++) {\n            collisionGrid[coordsToIndex(x, y)] = p8g::random() < 0.25f;\n        }\n    }\n    // ensure there is no collision at the start point\n    collisionGrid[coordsToIndex(cols / 2, rows / 2)] = false;\n}\n\nvoid initAStar() {\n    delete astar;\n    astar = new AStar(collisionGrid, cols, rows, true);\n    path = astar->findPath(cols / 2, rows / 2, gx, gy);\n}\n\nvoid p8g::draw() {\n    background(255.f);\n    for (int y = 0; y < rows; y++) {\n        for (int x = 0; x < cols; x++) {\n            if (collisionGrid[coordsToIndex(x, y)]) {\n                stroke(0.f);\n                strokeWeight(w);\n                point(x * w + w / 2.0f, y * h + h / 2.0f);\n            }\n        }\n    }\n    if (path.size() > 1) {\n        for (int i = 1; i < path.size(); i++) {\n            stroke(255.f, 0.f, 255.f);\n            strokeWeight(wh);\n            line(\n                path[i - 1].first * w + wh,\n                path[i - 1].second * h + hh,\n                path[i].first * w + wh,\n                path[i].second * h + hh\n            );\n        }\n    }\n}\n\nvoid p8g::mouseMoved() {\n    int prevGx = gx, prevGy = gy;\n    gx = glm::clamp<int>(glm::min(mouseX, (float) width) / w, 0, cols - 1);\n    gy = glm::clamp<int>(glm::min(mouseY, (float) height) / h, 0, rows - 1);\n    if (gx != prevGx || gy != prevGy) {\n        initAStar();\n    }\n}\n\nint main() {\n    const int WIDTH = 512;\n    const int HEIGHT = 512;\n    w = (float) WIDTH / cols;\n    h = (float) HEIGHT / rows;\n    wh = w / 2.0f;\n    hh = h / 2.0f;\n    initCollisionGrid();\n    initAStar();\n    run(WIDTH, HEIGHT, "A*");\n}'))))}g.isMDXComponent=!0},4678:function(n,t,e){e.d(t,{Z:function(){return s}});var o=e(7294),i=e(6649),r=e(4996);function s(n){return o.createElement(i.Z,{src:(0,r.Z)(n.src),style:{width:"1px",minWidth:"100%"}})}}}]);