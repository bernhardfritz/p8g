"use strict";(self.webpackChunkp8g_docs=self.webpackChunkp8g_docs||[]).push([[3191],{5910:function(e,n,r){r.r(n),r.d(n,{assets:function(){return p},contentTitle:function(){return T},default:function(){return h},frontMatter:function(){return c},metadata:function(){return f},toc:function(){return b}});var a=r(3117),t=r(102),u=(r(7294),r(3905)),i=r(5488),o=r(5162),d=r(6975),l=r(4678),s=["components"],c={description:"C"},T="Quadtree",f={unversionedId:"quadtree",id:"quadtree",title:"Quadtree",description:"C",source:"@site/examples/quadtree.md",sourceDirName:".",slug:"/quadtree",permalink:"/p8g/examples/quadtree",draft:!1,editUrl:"https://github.com/bernhardfritz/p8g/edit/master/docs/examples/quadtree.md",tags:[],version:"current",frontMatter:{description:"C"},sidebar:"examples",previous:{title:"Noise",permalink:"/p8g/examples/noise"}},p={},b=[],m={toc:b};function h(e){var n=e.components,r=(0,t.Z)(e,s);return(0,u.kt)("wrapper",(0,a.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,u.kt)("h1",{id:"quadtree"},"Quadtree"),(0,u.kt)(l.Z,{src:"/examples/quadtree.html",mdxType:"Emscripten"}),(0,u.kt)(i.Z,{groupId:"lang",mdxType:"Tabs"},(0,u.kt)(o.Z,{value:"c",label:"C",mdxType:"TabItem"},(0,u.kt)(d.Z,{language:"c",title:"aabb.c",mdxType:"CodeBlock"},'#include "aabb.h"\n#define USING_NAMESPACE_P8G\n#include "p8g.h"\n\nint AABB_contains_point(AABB* aabb, XY point) {\n    return fabs(aabb->center.x - point.x) <= aabb->halfDimension\n        && fabs(aabb->center.y - point.y) <= aabb->halfDimension;\n}\n\nint AABB_intersects_AABB(AABB* aabb, AABB other) {\n    float sum = aabb->halfDimension + other.halfDimension;\n    return fabs(aabb->center.x - other.center.x) <= sum\n        || fabs(aabb->center.y - other.center.y) <= sum;\n}\n\nvoid AABB_draw(AABB* aabb, vec4 color) {\n    push();\n    stroke(color);\n    strokeWeight(1.f);\n    noFill();\n    rectMode(RADIUS);\n    rect(aabb->center.x, aabb->center.y, aabb->halfDimension, aabb->halfDimension);\n    pop();\n}'),(0,u.kt)(d.Z,{language:"c",title:"aabb.h",mdxType:"CodeBlock"},'#ifndef AABB_H\n#define AABB_H\n\n#include "linmath.h"\n#include "xy.h"\n\ntypedef struct {\n    XY center;\n    float halfDimension;\n} AABB;\n\nint AABB_contains_point(AABB* aabb, XY point);\nint AABB_intersects_AABB(AABB* aabb, AABB other);\nvoid AABB_draw(AABB* aabb, vec4 color);\n\n#endif /* AABB_H */'),(0,u.kt)(d.Z,{language:"c",title:"quadtree.c",mdxType:"CodeBlock"},'#include "quadtree.h"\n\n#include <stdlib.h>\n#include "stb_ds.h"\n\n#define USING_NAMESPACE_P8G\n#include "p8g.h"\n\n#define CAPACITY 4\n\nstatic void QuadTree_subdivide(QuadTree* quadTree) {\n    float halfDimension = quadTree->boundary.halfDimension / 2.f;\n    quadTree->nw = QuadTree_new((AABB) {\n        .center = { quadTree->boundary.center.x - halfDimension, quadTree->boundary.center.y - halfDimension },\n        .halfDimension = halfDimension\n    });\n    quadTree->ne = QuadTree_new((AABB) {\n        .center = { quadTree->boundary.center.x + halfDimension, quadTree->boundary.center.y - halfDimension },\n        .halfDimension = halfDimension\n    });\n    quadTree->sw = QuadTree_new((AABB) {\n        .center = { quadTree->boundary.center.x - halfDimension, quadTree->boundary.center.y + halfDimension },\n        .halfDimension = halfDimension\n    });\n    quadTree->se = QuadTree_new((AABB) {\n        .center = { quadTree->boundary.center.x + halfDimension, quadTree->boundary.center.y + halfDimension },\n        .halfDimension = halfDimension\n    });\n    int length = arrlen(quadTree->points);\n    for (int i = 0; i < length; i++) {\n        if (QuadTree_insert(quadTree->nw, quadTree->points[i])\n            || QuadTree_insert(quadTree->ne, quadTree->points[i])\n            || QuadTree_insert(quadTree->sw, quadTree->points[i])\n            || QuadTree_insert(quadTree->se, quadTree->points[i])) {\n            continue;\n        }\n    }\n}\n\nQuadTree* QuadTree_new(AABB aabb) {\n    QuadTree* quadTree = (QuadTree*) malloc(sizeof(QuadTree));\n    quadTree->boundary = aabb;\n    quadTree->points = NULL;\n    quadTree->nw = NULL;\n    quadTree->ne = NULL;\n    quadTree->sw = NULL;\n    quadTree->se = NULL;\n    return quadTree;\n}\n\nint QuadTree_insert(QuadTree* quadTree, XY point) {\n    if (!AABB_contains_point(&quadTree->boundary, point)) {\n        return 0;\n    }\n    if (arrlen(quadTree->points) < CAPACITY) {\n        arrpush(quadTree->points, point);\n        return 1;\n    }\n    if (quadTree->nw == NULL) {\n        QuadTree_subdivide(quadTree);\n    }\n    return QuadTree_insert(quadTree->nw, point)\n        || QuadTree_insert(quadTree->ne, point)\n        || QuadTree_insert(quadTree->sw, point)\n        || QuadTree_insert(quadTree->se, point);\n}\n\nvoid QuadTree_queryRange(QuadTree* quadTree, AABB range, XY** pointsInRange) {\n    if (!AABB_intersects_AABB(&quadTree->boundary, range)) {\n        return;\n    }\n    int length = arrlen(quadTree->points);\n    for (int i = 0; i < length; i++) {\n        if (AABB_contains_point(&range, quadTree->points[i])) {\n            arrpush(*pointsInRange, quadTree->points[i]);\n        }\n    }\n    if (quadTree->nw == NULL) {\n        return;\n    }\n    QuadTree_queryRange(quadTree->nw, range, pointsInRange);\n    QuadTree_queryRange(quadTree->ne, range, pointsInRange);\n    QuadTree_queryRange(quadTree->sw, range, pointsInRange);\n    QuadTree_queryRange(quadTree->se, range, pointsInRange);\n}\n\nvoid QuadTree_draw(QuadTree* quadTree, vec4 boundaryColor, vec4 pointColor) {\n    AABB_draw(&quadTree->boundary, boundaryColor);\n    int length = arrlen(quadTree->points);\n    for (int i = 0; i < length; i++) {\n        XY_draw(&quadTree->points[i], pointColor);\n    }\n    if (quadTree->nw == NULL) {\n        return;\n    }\n    QuadTree_draw(quadTree->nw, boundaryColor, pointColor);\n    QuadTree_draw(quadTree->ne, boundaryColor, pointColor);\n    QuadTree_draw(quadTree->sw, boundaryColor, pointColor);\n    QuadTree_draw(quadTree->se, boundaryColor, pointColor);\n}\n\nvoid QuadTree_destroy(QuadTree* quadTree) {\n    arrfree(quadTree->points);\n    if (quadTree->nw == NULL) {\n        return;\n    }\n    QuadTree_destroy(quadTree->nw);\n    QuadTree_destroy(quadTree->ne);\n    QuadTree_destroy(quadTree->sw);\n    QuadTree_destroy(quadTree->se);\n}'),(0,u.kt)(d.Z,{language:"c",title:"quadtree.h",mdxType:"CodeBlock"},'#ifndef QUADTREE_H\n#define QUADTREE_H\n\n#include "linmath.h"\n#include "aabb.h"\n#include "xy.h"\n\nstruct QuadTree {\n    AABB boundary;\n    XY *points;\n    struct QuadTree *nw, *ne, *sw, *se;\n};\ntypedef struct QuadTree QuadTree;\n\nQuadTree* QuadTree_new(AABB aabb);\nint QuadTree_insert(QuadTree* quadTree, XY point);\nvoid QuadTree_queryRange(QuadTree* quadTree, AABB range, XY** pointsInRange);\nvoid QuadTree_draw(QuadTree* quadTree, vec4 boundaryColor, vec4 pointColor);\nvoid QuadTree_destroy(QuadTree* quadTree);\n\n#endif /* QUADTREE_H */'),(0,u.kt)(d.Z,{language:"c",title:"sketch.c",mdxType:"CodeBlock"},'#include "aabb.h"\n\n#include "stb_ds.h"\n\n#define USING_NAMESPACE_P8G\n#include "p8g.h"\n\n#include "quadtree.h"\n\n#define HALF_DIMENSION 160\n\nvec4 GREEN = { 0.f, 255.f, 0.f, 255.f };\nvec4 WHITE = { 255.f, 255.f, 255.f, 255.f };\n\nQuadTree quadTree = {\n    .boundary = {\n        .center = {\n            .x = HALF_DIMENSION,\n            .y = HALF_DIMENSION,\n        },\n        .halfDimension = HALF_DIMENSION,\n    },\n    .points = NULL,\n    .nw = NULL,\n    .ne = NULL,\n    .sw = NULL,\n    .se = NULL,\n};\nAABB aabb = {\n    .center = {\n        .x = 0.f,\n        .y = 0.f,\n    },\n    .halfDimension = 40.f,\n};\n\nvoid draw() {\n    background(0);\n    QuadTree_draw(&quadTree, WHITE, WHITE);\n    AABB_draw(&aabb, GREEN);\n    XY* pointsInRange = NULL;\n    QuadTree_queryRange(&quadTree, aabb, &pointsInRange);\n    int length = arrlen(pointsInRange);\n    for (int i = 0; i < length; i++) {\n        XY_draw(&pointsInRange[i], GREEN);\n    }\n    arrfree(pointsInRange);\n}\n\nvoid keyPressed() {}\nvoid keyReleased() {}\n\nvoid mouseMoved() {\n    aabb.center.x = mouseX;\n    aabb.center.y = mouseY;\n}\n\nvoid mousePressed() {}\nvoid mouseReleased() {}\nvoid mouseWheel(float delta) {}\n\nint main() {\n    vec2 center = { HALF_DIMENSION, HALF_DIMENSION };\n    for (int i = 0; i < 1000; i++) {\n        float r = random(HALF_DIMENSION);\n        float phi = random(2.f * M_PI);\n        vec2 v = { cosf(phi), sinf(phi) };\n        vec2_scale(v, v, r);\n        vec2_add(v, center, v);\n        QuadTree_insert(&quadTree, (XY) { .x = v[0], .y = v[1] });\n    }\n    run(2 * HALF_DIMENSION, 2 * HALF_DIMENSION, "Quadtree");\n#ifndef __EMSCRIPTEN__\n    QuadTree_destroy(&quadTree);\n#endif\n}'),(0,u.kt)(d.Z,{language:"c",title:"xy.c",mdxType:"CodeBlock"},'#include "xy.h"\n\n#define USING_NAMESPACE_P8G\n#include "p8g.h"\n\nvoid XY_draw(XY* xy, vec4 color) {\n    push();\n    stroke(color);\n    strokeWeight(3.f);\n    point(xy->x, xy->y);\n    pop();\n}'),(0,u.kt)(d.Z,{language:"c",title:"xy.h",mdxType:"CodeBlock"},'#ifndef XY_H\n#define XY_H\n\n#include "linmath.h"\n\ntypedef struct {\n    float x;\n    float y;\n} XY;\n\nvoid XY_draw(XY* xy, vec4 color);\n\n#endif /* XY_H */'))))}h.isMDXComponent=!0},5162:function(e,n,r){r.d(n,{Z:function(){return i}});var a=r(7294),t=r(6010),u="tabItem_Ymn6";function i(e){var n=e.children,r=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",className:(0,t.Z)(u,i),hidden:r},n)}},5488:function(e,n,r){r.d(n,{Z:function(){return f}});var a=r(3117),t=r(7294),u=r(6010),i=r(2389),o=r(7392),d=r(7094),l=r(2466),s="tabList__CuJ",c="tabItem_LNqP";function T(e){var n,r,i=e.lazy,T=e.block,f=e.defaultValue,p=e.values,b=e.groupId,m=e.className,h=t.Children.map(e.children,(function(e){if((0,t.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),_=null!=p?p:h.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),A=(0,o.l)(_,(function(e,n){return e.value===n.value}));if(A.length>0)throw new Error('Docusaurus error: Duplicate values "'+A.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var q=null===f?f:null!=(n=null!=f?f:null==(r=h.find((function(e){return e.props.default})))?void 0:r.props.value)?n:h[0].props.value;if(null!==q&&!_.some((function(e){return e.value===q})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+q+'" but none of its children has the corresponding value. Available values are: '+_.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=(0,d.U)(),y=v.tabGroupChoices,B=v.setTabGroupChoices,g=(0,t.useState)(q),Q=g[0],w=g[1],N=[],I=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=b){var E=y[b];null!=E&&E!==Q&&_.some((function(e){return e.value===E}))&&w(E)}var D=function(e){var n=e.currentTarget,r=N.indexOf(n),a=_[r].value;a!==Q&&(I(n),w(a),null!=b&&B(b,String(a)))},x=function(e){var n,r=null;switch(e.key){case"ArrowRight":var a,t=N.indexOf(e.currentTarget)+1;r=null!=(a=N[t])?a:N[0];break;case"ArrowLeft":var u,i=N.indexOf(e.currentTarget)-1;r=null!=(u=N[i])?u:N[N.length-1]}null==(n=r)||n.focus()};return t.createElement("div",{className:(0,u.Z)("tabs-container",s)},t.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,u.Z)("tabs",{"tabs--block":T},m)},_.map((function(e){var n=e.value,r=e.label,i=e.attributes;return t.createElement("li",(0,a.Z)({role:"tab",tabIndex:Q===n?0:-1,"aria-selected":Q===n,key:n,ref:function(e){return N.push(e)},onKeyDown:x,onFocus:D,onClick:D},i,{className:(0,u.Z)("tabs__item",c,null==i?void 0:i.className,{"tabs__item--active":Q===n})}),null!=r?r:n)}))),i?(0,t.cloneElement)(h.filter((function(e){return e.props.value===Q}))[0],{className:"margin-top--md"}):t.createElement("div",{className:"margin-top--md"},h.map((function(e,n){return(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==Q})}))))}function f(e){var n=(0,i.Z)();return t.createElement(T,(0,a.Z)({key:String(n)},e))}},4678:function(e,n,r){r.d(n,{Z:function(){return i}});var a=r(7294),t=r(6649),u=r(4996);function i(e){return a.createElement(t.Z,{src:(0,u.Z)(e.src),style:{width:"1px",minWidth:"100%"}})}}}]);